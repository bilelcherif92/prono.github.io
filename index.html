<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pronostics ‚Äî Tirage √©quitable (votes non-joueurs)</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; background:#fafafa; }
  h1 { margin-bottom: 0.2rem; }
  .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; margin-bottom: 16px; background:white; box-shadow: 0 1px 3px rgba(0,0,0,.06); }
  label { display:block; font-weight: 600; margin-bottom: 6px; }
  input[type="text"], input[type="number"], select { padding: 8px; border: 1px solid #d1d5db; border-radius: 8px; width: 100%; box-sizing: border-box; }
  button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; background: #111827; color: white; font-weight: 600; }
  button.secondary { background: #374151; }
  button.ghost { background: #eef2ff; color: #111827; }
  table { width: 100%; border-collapse: collapse; }
  th, td { border-bottom: 1px solid #e5e7eb; padding: 8px; text-align: left; }
  th { background: #f3f4f6; }
  .muted { color: #6b7280; }
  .row { display:flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  .col { flex: 1; min-width: 240px; }
  .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; font-size: 12px; background: #f3f4f6; }
</style>
</head>
<body>
  <h1>üéØ Pronostics ‚Äî Tirage √©quitable</h1>
  <p class="muted">Tire 1‚Äì3 joueurs (√©quit√©), saisis <b>Cote</b> & <b>Passe</b> (Oui = +cote, Non = ‚àícote). Les non-joueurs peuvent voter : üëç un prono gagnant = +5, üö´ rien ne passe = +10. Sauvegarde auto incluse.</p>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>Joueurs (s√©par√©s par des virgules)</label>
        <input id="players" type="text" value="kader, youss, Axel, Noty, Joueur5, Joueur6, Joueur7, Joueur8, Joueur9, Joueur10" />
        <div class="muted" style="margin-top:6px;">Ex : Alice, Bob, Charly</div>
      </div>
      <div class="col" style="max-width:180px;">
        <label>Nombre √† tirer (1‚Äì3)</label>
        <input id="count" type="number" min="1" max="3" step="1" value="3" />
      </div>
      <div class="col" style="max-width:520px;">
        <label>&nbsp;</label>
        <div class="row">
          <button id="drawBtn">Tirer</button>
          <button id="resetBtn" class="secondary">R√©initialiser</button>
          <button id="exportBtn" class="ghost">Exporter CSV</button>
          <input id="importFile" type="file" accept=".csv" style="display:none;">
          <button id="importBtn" class="ghost">Importer CSV</button>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row" style="align-items:center;">
      <div class="col"><h3 style="margin:6px 0;">R√©sultat du tirage</h3></div>
      <div class="col" style="text-align:right;">
        <span class="pill"><span class="muted">√âcart (max‚Äìmin) : </span><span id="gapSpan">0</span></span>
      </div>
    </div>
    <div id="results" style="font-size:18px; font-weight:700; margin-top:8px;"></div>
  </div>

  <div class="card">
    <h3 style="margin:6px 0;">Historique des pronos</h3>
    <table id="historyTable">
      <thead>
        <tr><th>Date/Heure</th><th>Tirage</th><th>Joueur</th><th>Pari</th><th>Cote</th><th>Passe</th><th>Points</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card">
    <h3 style="margin:6px 0;">Votes des non-joueurs</h3>
    <div class="row">
      <div class="col">
        <label>Tirage</label>
        <select id="voteGid"></select>
      </div>
      <div class="col">
        <label>Votant (non tir√© sur ce tirage)</label>
        <select id="voteVoter"></select>
      </div>
      <div class="col">
        <label>Choix</label>
        <select id="voteChoice">
          <option value="">‚Äî choisir ‚Äî</option>
          <!-- dynamiquement: joueur A / joueur B / joueur C / RIEN -->
        </select>
      </div>
      <div class="col" style="max-width:220px;">
        <label>&nbsp;</label>
        <button id="addVoteBtn">Ajouter le vote</button>
      </div>
    </div>

    <table id="votesTable" style="margin-top:12px;">
      <thead>
        <tr><th>Tirage</th><th>Votant</th><th>Choix</th><th>Points</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card">
    <h3 style="margin:6px 0;">Classement</h3>
    <table id="boardTable">
      <thead>
        <tr><th>Joueur</th><th>Nb pronos</th><th>Total points</th><th>Taux de r√©ussite</th><th>Moyenne cote gagn√©e</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
(function(){
  const LS_KEY = "prono_state_votes_v1";
  const playersInput = document.getElementById('players');
  const kInput = document.getElementById('count');
  const drawBtn = document.getElementById('drawBtn');
  const resetBtn = document.getElementById('resetBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const importFile = document.getElementById('importFile');
  const gapSpan = document.getElementById('gapSpan');
  const results = document.getElementById('results');
  const historyTBody = document.querySelector('#historyTable tbody');
  const boardTBody = document.querySelector('#boardTable tbody');

  const voteGid = document.getElementById('voteGid');
  const voteVoter = document.getElementById('voteVoter');
  const voteChoice = document.getElementById('voteChoice');
  const addVoteBtn = document.getElementById('addVoteBtn');
  const votesTBody = document.querySelector('#votesTable tbody');

  let players = [];
  // pronos: { ts, gid, joueur, pari, cote, passe }
  let history = [];
  // votes: { gid, voter, choice }  (choice = joueur|NONE)
  let votes = [];

  // ---------- Helpers & validation cote ----------
  function sanitizeCoteText(s) {
    s = String(s).replace(/[^\d.,]/g, "");
    const firstSep = s.search(/[.,]/);
    if (firstSep !== -1) {
      const head = s.slice(0, firstSep + 1);
      const tail = s.slice(firstSep + 1).replace(/[.,]/g, "");
      s = head + tail;
    }
    return s;
  }
  function parseCote(s) {
    const v = Number(String(s).replace(",", "."));
    return Number.isFinite(v) ? v : null;
  }
  function formatFR2(n) {
    return n.toLocaleString("fr-FR", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }
  function fmtTs(ts) { return new Date(ts).toLocaleString(); }

  // ---------- Sauvegarde / Restauration ----------
  function save() {
    const state = { playersText: playersInput.value, k: kInput.value, history, votes };
    try { localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch(e) {}
  }
  function load() {
    try {
      const data = localStorage.getItem(LS_KEY);
      if (!data) return;
      const s = JSON.parse(data);
      if (s.playersText) playersInput.value = s.playersText;
      if (s.k) kInput.value = s.k;
      if (Array.isArray(s.history)) history = s.history;
      if (Array.isArray(s.votes)) votes = s.votes;
    } catch(e) {}
  }
  function clearAll() {
    if (!confirm("Tout effacer (historique + votes + sauvegarde) ?")) return;
    history = [];
    votes = [];
    results.textContent = "";
    localStorage.removeItem(LS_KEY);
    renderAll();
  }

  // ---------- Tirages ----------
  function parsePlayers() {
    players = playersInput.value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  function fairDraw(k) {
    const counts = {}; players.forEach(p => counts[p]=0);
    history.forEach(h => { if (counts.hasOwnProperty(h.joueur)) counts[h.joueur] += 1; });
    const arr = players.map(p => ({p, c:counts[p], r:Math.random()}));
    arr.sort((a,b)=> (a.c - b.c) || (a.r - b.r));
    return arr.slice(0, k).map(x => x.p);
  }
  function getTiragesMap() {
    // gid -> { ts, joueurs:[...] }
    const res = {};
    history.forEach(h => {
      if (!res[h.gid]) res[h.gid] = { ts: h.ts, joueurs: [] };
      if (!res[h.gid].joueurs.includes(h.joueur)) res[h.gid].joueurs.push(h.joueur);
    });
    return res;
  }

  // ---------- Points pronos (+/- cote) ----------
  function computeProNoPointsArray() {
    return history.map(h => {
      const cote = parseCote(h.cote);
      const p = String(h.passe||'').toLowerCase();
      if (cote == null) return 0;
      if (p === 'oui') return +cote;
      if (p === 'non') return -cote;
      return 0;
    });
  }

  // ---------- Points votes (non-joueurs) ----------
  function computeVotePointsMap() {
    // Pour chaque gid : si 0 pronos passent -> votes "NONE" = +10
    // Sinon, pour chaque vote choice=un joueur qui passe -> +5
    const passByGid = {};
    history.forEach(h => {
      const p = String(h.passe||'').toLowerCase();
      if (!passByGid[h.gid]) passByGid[h.gid] = { passed: new Set(), total: 0 };
      if (p === 'oui') passByGid[h.gid].passed.add(h.joueur);
      passByGid[h.gid].total += 1;
    });

    const voterPoints = {}; // voter -> points
    votes.forEach(v => {
      if (!voterPoints[v.voter]) voterPoints[v.voter] = 0;
      const info = passByGid[v.gid] || { passed: new Set(), total: 0 };
      const zeroPassed = info.passed.size === 0 && info.total > 0;
      if (v.choice === 'NONE') {
        if (zeroPassed) voterPoints[v.voter] += 10;
      } else {
        if (info.passed.has(v.choice)) voterPoints[v.voter] += 5;
      }
    });
    return voterPoints;
  }

  // ---------- Rendu Historique (√©dition fluide + validation cote) ----------
  function renderHistory() {
    historyTBody.innerHTML = '';
    const rows = [...history].map((h, idx) => ({...h, _i:idx})).sort((a,b)=> b.ts - a.ts).slice(0, 500);

    const proPoints = computeProNoPointsArray();

    rows.forEach(h => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${fmtTs(h.ts)}</td>
        <td>${h.gid}</td>
        <td>${h.joueur}</td>
        <td contenteditable="true">${h.pari || ''}</td>
        <td contenteditable="true">${h.cote || ''}</td>
        <td>
          <select class="sel-passe">
            <option value="" ${!h.passe ? 'selected' : ''}></option>
            <option value="Oui" ${h.passe === 'Oui' ? 'selected' : ''}>Oui</option>
            <option value="Non" ${h.passe === 'Non' ? 'selected' : ''}>Non</option>
          </select>
        </td>
        <td class="pts-cell">${(proPoints[h._i] ?? 0).toFixed(2)}</td>
      `;

      const tdPari   = tr.children[3];
      const tdCote   = tr.children[4];
      const selPasse = tr.querySelector('.sel-passe');
      const ptsCell  = tr.querySelector('.pts-cell');

      function refreshPointsCell() {
        const arr = computeProNoPointsArray();
        ptsCell.textContent = (arr[h._i] ?? 0).toFixed(2);
        save();
        recomputeBoard();
        renderVotes(); // car les votes d√©pendent des r√©sultats
      }

      // Validation clavier cote
      tdCote.addEventListener('keydown', (e) => {
        const allowed = ['Backspace','Delete','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','Tab','Enter'];
        if (allowed.includes(e.key)) return;
        if (e.key.match(/^[0-9.,]$/)) return;
        e.preventDefault();
      });

      tdPari.addEventListener('input', () => {
        history[h._i].pari = tdPari.innerText.trim();
        save();
      });

      tdCote.addEventListener('input', () => {
        const clean = sanitizeCoteText(tdCote.innerText);
        if (tdCote.innerText !== clean) {
          tdCote.innerText = clean;
          const sel = window.getSelection(); const range = document.createRange();
          range.selectNodeContents(tdCote); range.collapse(false);
          sel.removeAllRanges(); sel.addRange(range);
        }
        history[h._i].cote = clean.trim();
        refreshPointsCell();
      });

      tdCote.addEventListener('blur', () => {
        const v = parseCote(history[h._i].cote);
        if (v !== null) {
          history[h._i].cote = formatFR2(v);
          tdCote.innerText = history[h._i].cote;
          refreshPointsCell();
        }
      });

      selPasse.addEventListener('change', () => {
        history[h._i].passe = selPasse.value;
        refreshPointsCell();
      });

      historyTBody.appendChild(tr);
    });
  }

  // ---------- Rendu Votes ----------
  function renderVoteSelectors() {
    // Remplir la liste des tirages (tri par date desc)
    const tmap = getTiragesMap();
    const gids = Object.keys(tmap).sort((a,b)=> (tmap[b].ts - tmap[a].ts));
    voteGid.innerHTML = '';
    gids.forEach(g => {
      const opt = document.createElement('option');
      opt.value = g;
      opt.textContent = `${g} ‚Äî [${tmap[g].joueurs.join(' ¬∑ ')}]`;
      voteGid.appendChild(opt);
    });
    // Pr√©parer votant et choix selon gid s√©lectionn√©
    updateVoterAndChoice();
  }

  function updateVoterAndChoice() {
    const g = voteGid.value;
    const tmap = getTiragesMap();
    const picked = new Set((tmap[g]?.joueurs)||[]);
    // Votants possibles = joueurs - picked
    voteVoter.innerHTML = '';
    players.filter(p => !picked.has(p)).forEach(p => {
      const opt = document.createElement('option'); opt.value = p; opt.textContent = p; voteVoter.appendChild(opt);
    });
    // Choix possibles = joueurs tir√©s + "Rien ne passe"
    voteChoice.innerHTML = '';
    const ph = document.createElement('option'); ph.value = ''; ph.textContent='‚Äî choisir ‚Äî'; voteChoice.appendChild(ph);
    (tmap[g]?.joueurs || []).forEach(p => {
      const opt = document.createElement('option'); opt.value = p; opt.textContent = `üëç ${p}`; voteChoice.appendChild(opt);
    });
    const optNone = document.createElement('option'); optNone.value = 'NONE'; optNone.textContent = 'üö´ Rien ne passe';
    voteChoice.appendChild(optNone);
  }

  function renderVotes() {
    renderVoteSelectors();
    // afficher tableau des votes + points
    votesTBody.innerHTML = '';
    const voterPts = computeVotePointsMap();
    votes.forEach(v => {
      const tr = document.createElement('tr');
      const pts = (voterPts[v.voter] && 0) ? 0 : 0; // placeholder (on affiche par ligne ci-dessous)
      let linePts = 0;
      // recompute per-line quickly:
      const passByGid = {};
      history.forEach(h => {
        const p = String(h.passe||'').toLowerCase();
        if (!passByGid[h.gid]) passByGid[h.gid] = { passed: new Set(), total: 0 };
        if (p === 'oui') passByGid[h.gid].passed.add(h.joueur);
        passByGid[h.gid].total += 1;
      });
      const info = passByGid[v.gid] || { passed: new Set(), total: 0 };
      const zeroPassed = info.passed.size === 0 && info.total > 0;
      if (v.choice === 'NONE') linePts = zeroPassed ? 10 : 0;
      else linePts = info.passed.has(v.choice) ? 5 : 0;

      tr.innerHTML = `<td>${v.gid}</td><td>${v.voter}</td><td>${v.choice==='NONE'?'Rien ne passe':v.choice}</td><td>${linePts.toFixed(2)}</td>`;
      votesTBody.appendChild(tr);
    });
  }

  addVoteBtn.addEventListener('click', () => {
    const g = voteGid.value;
    const voter = voteVoter.value;
    const choice = voteChoice.value;
    if (!g || !voter || !choice) { alert("S√©lectionne tirage, votant et choix."); return; }
    // √©viter doublons: un votant = un seul vote par tirage
    if (votes.find(v => v.gid===g && v.voter===voter)) {
      alert("Ce votant a d√©j√† vot√© pour ce tirage."); return;
    }
    votes.push({ gid:g, voter, choice });
    save();
    renderVotes();
    recomputeBoard();
  });

  // ---------- Classement (pronos +/- + votes) ----------
  function recomputeBoard() {
    const proPoints = computeProNoPointsArray(); // par ligne de history
    const voterPtsMap = computeVotePointsMap();  // cumul√© par votant

    const counts = {}, wins = {}, sumTotal = {}, sumCoteWin = {};
    players.forEach(p => { counts[p]=0; wins[p]=0; sumTotal[p]=0; sumCoteWin[p]=0; });

    history.forEach((h, idx) => {
      if (!counts.hasOwnProperty(h.joueur)) return;
      counts[h.joueur] += 1;
      sumTotal[h.joueur] += proPoints[idx] || 0;

      const cote = parseCote(h.cote);
      if (String(h.passe||'').toLowerCase()==='oui' && cote!==null) {
        wins[h.joueur] += 1;
        sumCoteWin[h.joueur] += cote; // moyenne des cotes gagn√©es (sans votes)
      }
    });

    // ajouter points de votes aux totaux
    Object.keys(voterPtsMap).forEach(voter => {
      if (!sumTotal.hasOwnProperty(voter)) sumTotal[voter]=0;
      sumTotal[voter] += voterPtsMap[voter];
    });

    const rows = players.map(p => {
      const nb = counts[p]||0;
      const win = wins[p]||0;
      const taux = nb>0 ? (win/nb) : 0;
      const avg = win>0 ? (sumCoteWin[p]/win) : 0;
      const total = sumTotal[p]||0;
      return { joueur:p, nb, total, taux, avg };
    });

    boardTBody.innerHTML = '';
    rows.sort((a,b)=> b.total - a.total || b.taux - a.taux);
    rows.forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.joueur}</td><td>${r.nb}</td><td>${r.total.toFixed(2)}</td><td>${(r.taux*100).toFixed(1)}%</td><td>${r.avg.toFixed(2)}</td>`;
      boardTBody.appendChild(tr);
    });

    // √©cart max-min (nombre de pronos jou√©s)
    const vals = rows.map(r => r.nb);
    gapSpan.textContent = vals.length ? (Math.max(...vals)-Math.min(...vals)) : 0;
  }

  // ---------- Export / Import CSV (inclut votes) ----------
  function exportCSV() {
    // on exporte 2 sections: PRONOS puis VOTES (lisibles dans Excel)
    const lines = [];
    lines.push("SECTION,DateTime,TirageID,Joueur,Pari,Cote,Passe,Points/Valeur");
    const proPoints = computeProNoPointsArray();
    history.forEach((h,i) => {
      lines.push(`PRONO,"${new Date(h.ts).toISOString()}","${h.gid}","${(h.joueur||'').replace(/"/g,'""')}","${(h.pari||'').replace(/"/g,'""')}","${(h.cote||'').replace(/"/g,'""')}","${h.passe||''}",${(proPoints[i]||0).toFixed(2)}`);
    });
    lines.push(""); // blank
    lines.push("SECTION,TirageID,Votant,Choix,Points");
    // recalc points par vote pour export clair
    const passByGid = {};
    history.forEach(h => {
      const p = String(h.passe||'').toLowerCase();
      if (!passByGid[h.gid]) passByGid[h.gid] = { passed: new Set(), total: 0 };
      if (p === 'oui') passByGid[h.gid].passed.add(h.joueur);
      passByGid[h.gid].total += 1;
    });
    votes.forEach(v => {
      const info = passByGid[v.gid] || { passed: new Set(), total: 0 };
      const zeroPassed = info.passed.size === 0 && info.total > 0;
      let pts = 0;
      if (v.choice === 'NONE') pts = zeroPassed ? 10 : 0;
      else pts = info.passed.has(v.choice) ? 5 : 0;
      lines.push(`VOTE,"${v.gid}","${(v.voter||'').replace(/"/g,'""')}","${v.choice==='NONE'?'RIEN':(v.choice||'').replace(/"/g,'""')}",${pts.toFixed(2)}`);
    });

    const csv = lines.join("\r\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "pronostics_avec_votes.csv";
    a.click();
  }
  function importCSV(file) {
    // On accepte un CSV export√© par cet outil ; sinon, mieux vaut repartir sur un nouveau.
    const reader = new FileReader();
    reader.onload = e => {
      const text = e.target.result;
      const rows = text.split(/\r?\n/);
      const newHist = [];
      const newVotes = [];
      let section = "";
      for (let i=0; i<rows.length; i++) {
        const line = rows[i].trim();
        if (!line) continue;
        if (line.startsWith("SECTION,")) {
          if (line.includes("DateTime")) { section = "PRONO"; continue; }
          if (line.includes("TirageID,Votant")) { section = "VOTE"; continue; }
          continue;
        }
        const parts = parseCSVLine(line);
        if (section === "PRONO") {
          // PRONO,"iso","gid","joueur","pari","cote","passe",points
          const iso = parts[1], gid = parts[2], joueur=parts[3], pari=parts[4], cote=parts[5], passe=parts[6];
          const ts = Date.parse(iso) || Date.now();
          newHist.push({ts, gid, joueur, pari, cote, passe});
        } else if (section === "VOTE") {
          // VOTE,"gid","votant","choix",points
          const gid = parts[1], voter = parts[2], choix = (parts[3]==='RIEN'?'NONE':parts[3]);
          newVotes.push({gid, voter, choice: choix});
        }
      }
      history = newHist;
      votes = newVotes;
      renderAll();
    };
    reader.readAsText(file);
  }
  function parseCSVLine(line) {
    const re = /"(?:[^"]|"")*"|[^,]+/g;
    return (line.match(re) || []).map(s => {
      s = s.trim();
      if (s.startsWith('"') && s.endsWith('"')) s = s.slice(1,-1).replace(/""/g,'"');
      return s;
    });
  }

  // ---------- Actions ----------
  drawBtn.addEventListener('click', () => {
    parsePlayers();
    let k = parseInt(kInput.value, 10);
    if (!(k>=1 && k<=3)) k = 1;
    if (players.length === 0) { alert("Ajoute des joueurs d'abord."); return; }
    const chosen = fairDraw(Math.min(k, players.length));
    results.textContent = chosen.join(' ¬∑ ');
    const ts = Date.now();
    const gid = new Date(ts).toISOString().slice(0,10) + " " + ts; // id de tirage
    chosen.forEach(p => history.push({ts, gid, joueur:p, pari:"", cote:"", passe:""}));
    renderAll();
  });
  resetBtn.addEventListener('click', clearAll);
  playersInput.addEventListener('input', renderAll);
  kInput.addEventListener('input', renderAll);
  exportBtn.addEventListener('click', exportCSV);
  importBtn.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', (e)=> {
    if (e.target.files && e.target.files[0]) importCSV(e.target.files[0]);
    importFile.value = "";
  });

  // ---------- Rendus principaux ----------
  function renderAll() {
    parsePlayers();
    renderHistory();
    renderVotes();
    recomputeBoard();
    save();
  }

  // Init
  load();
  renderAll();
})();
</script>
</body>
</html>
